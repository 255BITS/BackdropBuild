from flask import Blueprint, render_template, Response
from shared.couch import db
from app.services.actions_service import ActionsService, decode_auth
from app.services.swagger_service import generate_openapi_spec_for_actions
import json
import datetime

import base64

public_bp = Blueprint('public', __name__)

@public_bp.get('/')
def home():
    return render_template('landing.html', count_apis=db.count_apis())

@public_bp.get("/public_apis")
def list_public_apis():
    apis = db.query_view('apis', 'public')
    return render_template("public_apis_index.html", apis=apis)

@public_bp.get("/public_apis/<api_id>")
def get_public_api(api_id):
    api = db.get(api_id)
    if api["type"] != "API" or api["visibility"] != "public":
        return redirect_to("/")
    return render_template("public_apis_show.html", api=api)

@public_bp.get('/openapi/<action_id>.json')
def get_openapi_spec(action_id):
    actions, apis, _ = ActionsService(None).get_details(action_id)
    #TODO 404?
    openapi_spec = generate_openapi_spec_for_actions(actions, apis)
    pretty_openapi_spec = json.dumps(openapi_spec, indent=4)
    
    # Return the pretty-printed JSON
    return pretty_openapi_spec, 200, {'Content-Type': 'application/json'}


@public_bp.get('/privacy_policy/<action_id>')
def get_privacy_policy(action_id):
    actions, apis, _ = ActionsService(None).get_details(action_id)
    privacy_policy = "In addition to the following GPTActionHub.com may monitor request input/output, collect analytics, and share them with the Actions authors.\n"
    privacy_policy += "------\n"
    for api in apis:
        privacy_policy += "Privacy policy for the API:"+api["title"]+"\n"
        privacy_policy += api["privacy_policy"]
        privacy_policy += "\n------\n"
    privacy_policy += f"This privacy policy is valid {datetime.datetime.now().isoformat()}. GPTActionHub.com and API authors reserve the right to modify any part of the policy in the future.\n"
    return Response(privacy_policy, mimetype="text/plain")

@public_bp.get('/setup-instructions')
def setup_instructions():
    return render_template("setup_instructions.html")

@public_bp.get('/sitemap.xml')
def sitemap():
    static_content_at = datetime.datetime.fromisoformat('2023-11-29T15:00:45.886476')
    apis = db.query_view('apis', 'public')
    last_public_update = None
    for api in apis:
        updated_at = datetime.datetime.fromisoformat(api["updated_at"])
        if last_public_update is None or updated_at > last_public_update:
            last_public_update = updated_at
    paths = {
        "/": {
            "last_updated": static_content_at
        },
        "/setup-instructions": {
            "last_updated": static_content_at
        },
        "/public_apis": {
            "last_updated": last_public_update,
        }
    }
    for api in apis:
        paths[f"/public_apis/{api['_id']}"] = {
            "last_updated": datetime.datetime.fromisoformat(api["updated_at"])
        }
    return render_template('sitemap.xml', paths=paths), 200, {'Content-Type': 'application/xml'}

@public_bp.get('/fixie_ai/<action_id>.tsx')
def get_fixie_tool(action_id):
    actions, apis, _ = ActionsService(None).get_details(action_id)
    prefix = """
# requires `npm install node-fetch`
import fetch from 'node-fetch';
"""
    javascript_start = """

const CLASSTool: Tool = {
  description: 'PATH_DESCRIPTION',
  parameters: {
"""
    javascript_param = """
    PARAM_NAME: {
      description: 'PARAM_DESCRIPTION',
      type: 'PARAM_TYPE',
      required: true,
    },
"""
    javascript_get_end = """
  },
  func: async ({ PARAM_NAMES }) => {
    const queryParams = new URLSearchParams({ PARAM_NAMES }).toString();
    const response = await fetch(`https://api.gptactionhub.com/ACTION_ID/OPERATION_ID?${queryParams}`, {
      method: 'METHOD',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `basic BASIC_AUTH`,
      }
    });
    if (!response.ok) {
      throw new Error(`GPTActionHub request failed: ${response.status} ${response.statusText} ${response.body}`);
    }
    return response.text();
  },
};
"""
    javascript_post_end = """
  },
  func: async ({ PARAM_NAMES }) => {
    const response = await fetch('https://api.gptactionhub.com/ACTION_ID/OPERATION_ID', {
      method: 'METHOD',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `basic BASIC_AUTH`,
      },
      body: JSON.stringify({ PARAM_NAMES }),
    });
    if (!response.ok) {
      throw new Error(`GPTActionHub request failed: ${response.status} ${response.statusText} ${response.body}`);
    }
    return response.text();
  },
};
"""
    addendum_start = """
# Add this to your tools
#const tools: Record<string, Tool> = {
"""
    addendum ="#  OPERATION_ID: CLASSTool,\n"
    addendum_end = """
#};
#<Sidekick systemMessage={systemMessage} tools={tools} />
"""
    response = "# Generated by https://gptactionhub.com/ACTION\n"
    js = prefix

    auths = db.get_auths_for_actions(action_id)
    for api in apis:
        for path in api["paths"]:
            js_instance = javascript_start
            js_instance = js_instance.replace("PATH_DESCRIPTION", api["description"].replace("'", ""))
            param_names = []
            for param in path["params"]:
                action_param = None

                for apilink in actions["api_links"]:
                    print(apilink)
                    for actionpath in apilink["paths"]:
                        if actionpath["path_id"] != path["path_id"]:
                            continue
                        for actionparam in actionpath["params"]:
                            if actionparam["name"] != param["name"]:
                                continue
                            action_param = actionparam
                if action_param["source"] != "gpt":
                    continue
                js_instance += javascript_param
                if "description" in param:
                    js_instance = js_instance.replace("PARAM_DESCRIPTION",param["description"])
                else:
                    js_instance = js_instance.replace("PARAM_DESCRIPTION","")
                js_instance = js_instance.replace("PARAM_NAME",param["name"])

                if param["type"] == "string":
                    js_instance = js_instance.replace("PARAM_TYPE", "string")
                elif param["type"] == "integer" or params["type"] == "float":
                    js_instance = js_instance.replace("PARAM_TYPE", "number")

                param_names.append(param["name"])

            if path["method"] == "GET":
                js_instance += javascript_get_end
            else:
                js_instance += javascript_post_end


            user_pass = decode_auth(auths[0])['value']
            user_pass_bytes = user_pass.encode('utf-8')

            base64_encoded = base64.b64encode(user_pass_bytes)

            # Convert byte string to a regular string for use in the header
            auth_header = base64_encoded.decode('utf-8')
            js_instance = js_instance.replace("BASIC_AUTH", auth_header)
            js_instance = js_instance.replace("CLASS", path["operation_id"].title())
            js_instance = js_instance.replace("ACTION_ID", action_id)
            js_instance = js_instance.replace("OPERATION_ID", path["operation_id"])
            js_instance = js_instance.replace("PARAM_NAMES", ",".join(param_names))
            js_instance = js_instance.replace("METHOD", path["method"])
            js += js_instance
    js += addendum_start
    for api in apis:
        for path in api["paths"]:
            js += addendum.replace("OPERATION_ID", path["operation_id"]).replace("CLASS", path["operation_id"].title())
    js += addendum_end
    return Response(js, mimetype="text/plain")
